{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\Alex\\\\Desktop\\\\project-3\\\\repo\\\\cod-tracker-auth\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Alex\\\\Desktop\\\\project-3\\\\repo\\\\cod-tracker-auth\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar Rx = require('rxjs');\n\nvar _require = require('rxjs/operators'),\n    defaultIfEmpty = _require.defaultIfEmpty,\n    delay = _require.delay,\n    filter = _require.filter,\n    mapTo = _require.mapTo,\n    skip = _require.skip,\n    take = _require.take,\n    takeWhile = _require.takeWhile;\n\nvar defaults = require('../defaults');\n\nmodule.exports = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function RestartProcess(_ref) {\n    var delay = _ref.delay,\n        tries = _ref.tries,\n        logger = _ref.logger,\n        scheduler = _ref.scheduler;\n\n    _classCallCheck(this, RestartProcess);\n\n    this.delay = +delay || defaults.restartDelay;\n    this.tries = +tries || defaults.restartTries;\n    this.logger = logger;\n    this.scheduler = scheduler;\n  }\n\n  _createClass(RestartProcess, [{\n    key: \"handle\",\n    value: function handle(commands) {\n      var _this = this;\n\n      if (this.tries === 0) {\n        return commands;\n      }\n\n      commands.map(function (command) {\n        return command.close.pipe(take(_this.tries), takeWhile(function (code) {\n          return code !== 0;\n        }));\n      }).map(function (failure, index) {\n        return Rx.merge( // Delay the emission (so that the restarts happen on time),\n        // explicitly telling the subscriber that a restart is needed\n        failure.pipe(delay(_this.delay, _this.scheduler), mapTo(true)), // Skip the first N emissions (as these would be duplicates of the above),\n        // meaning it will be empty because of success, or failed all N times,\n        // and no more restarts should be attempted.\n        failure.pipe(skip(_this.tries), defaultIfEmpty(false))).subscribe(function (restart) {\n          var command = commands[index];\n\n          if (restart) {\n            _this.logger.logCommandEvent(\"\".concat(command.command, \" restarted\"), command);\n\n            command.start();\n          }\n        });\n      });\n      return commands.map(function (command) {\n        var closeStream = command.close.pipe(filter(function (value, emission) {\n          // We let all success codes pass, and failures only after restarting won't happen again\n          return value === 0 || emission >= _this.tries;\n        }));\n        return new Proxy(command, {\n          get(target, prop) {\n            return prop === 'close' ? closeStream : target[prop];\n          }\n\n        });\n      });\n    }\n  }]);\n\n  return RestartProcess;\n}();","map":{"version":3,"sources":["C:/Users/Alex/Desktop/project-3/repo/cod-tracker-auth/node_modules/concurrently/src/flow-control/restart-process.js"],"names":["Rx","require","defaultIfEmpty","delay","filter","mapTo","skip","take","takeWhile","defaults","module","exports","tries","logger","scheduler","restartDelay","restartTries","commands","map","command","close","pipe","code","failure","index","merge","subscribe","restart","logCommandEvent","start","closeStream","value","emission","Proxy","get","target","prop"],"mappings":";;;;AAAA,IAAMA,EAAE,GAAGC,OAAO,CAAC,MAAD,CAAlB;;eACwEA,OAAO,CAAC,gBAAD,C;IAAvEC,c,YAAAA,c;IAAgBC,K,YAAAA,K;IAAOC,M,YAAAA,M;IAAQC,K,YAAAA,K;IAAOC,I,YAAAA,I;IAAMC,I,YAAAA,I;IAAMC,S,YAAAA,S;;AAE1D,IAAMC,QAAQ,GAAGR,OAAO,CAAC,aAAD,CAAxB;;AAEAS,MAAM,CAACC,OAAP;AAAA;;AACI,gCAAiD;AAAA,QAAnCR,KAAmC,QAAnCA,KAAmC;AAAA,QAA5BS,KAA4B,QAA5BA,KAA4B;AAAA,QAArBC,MAAqB,QAArBA,MAAqB;AAAA,QAAbC,SAAa,QAAbA,SAAa;;AAAA;;AAC7C,SAAKX,KAAL,GAAa,CAACA,KAAD,IAAUM,QAAQ,CAACM,YAAhC;AACA,SAAKH,KAAL,GAAa,CAACA,KAAD,IAAUH,QAAQ,CAACO,YAAhC;AACA,SAAKH,MAAL,GAAcA,MAAd;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACH;;AANL;AAAA;AAAA,2BAQWG,QARX,EAQqB;AAAA;;AACb,UAAI,KAAKL,KAAL,KAAe,CAAnB,EAAsB;AAClB,eAAOK,QAAP;AACH;;AAEDA,MAAAA,QAAQ,CAACC,GAAT,CAAa,UAAAC,OAAO;AAAA,eAAIA,OAAO,CAACC,KAAR,CAAcC,IAAd,CACpBd,IAAI,CAAC,KAAI,CAACK,KAAN,CADgB,EAEpBJ,SAAS,CAAC,UAAAc,IAAI;AAAA,iBAAIA,IAAI,KAAK,CAAb;AAAA,SAAL,CAFW,CAAJ;AAAA,OAApB,EAGGJ,GAHH,CAGO,UAACK,OAAD,EAAUC,KAAV;AAAA,eAAoBxB,EAAE,CAACyB,KAAH,EACvB;AACA;AACAF,QAAAA,OAAO,CAACF,IAAR,CAAalB,KAAK,CAAC,KAAI,CAACA,KAAN,EAAa,KAAI,CAACW,SAAlB,CAAlB,EAAgDT,KAAK,CAAC,IAAD,CAArD,CAHuB,EAIvB;AACA;AACA;AACAkB,QAAAA,OAAO,CAACF,IAAR,CAAaf,IAAI,CAAC,KAAI,CAACM,KAAN,CAAjB,EAA+BV,cAAc,CAAC,KAAD,CAA7C,CAPuB,EAQzBwB,SARyB,CAQf,UAAAC,OAAO,EAAI;AACnB,cAAMR,OAAO,GAAGF,QAAQ,CAACO,KAAD,CAAxB;;AACA,cAAIG,OAAJ,EAAa;AACT,YAAA,KAAI,CAACd,MAAL,CAAYe,eAAZ,WAA+BT,OAAO,CAACA,OAAvC,iBAA4DA,OAA5D;;AACAA,YAAAA,OAAO,CAACU,KAAR;AACH;AACJ,SAd0B,CAApB;AAAA,OAHP;AAmBA,aAAOZ,QAAQ,CAACC,GAAT,CAAa,UAAAC,OAAO,EAAI;AAC3B,YAAMW,WAAW,GAAGX,OAAO,CAACC,KAAR,CAAcC,IAAd,CAAmBjB,MAAM,CAAC,UAAC2B,KAAD,EAAQC,QAAR,EAAqB;AAC/D;AACA,iBAAOD,KAAK,KAAK,CAAV,IAAeC,QAAQ,IAAI,KAAI,CAACpB,KAAvC;AACH,SAH4C,CAAzB,CAApB;AAKA,eAAO,IAAIqB,KAAJ,CAAUd,OAAV,EAAmB;AACtBe,UAAAA,GAAG,CAACC,MAAD,EAASC,IAAT,EAAe;AACd,mBAAOA,IAAI,KAAK,OAAT,GAAmBN,WAAnB,GAAiCK,MAAM,CAACC,IAAD,CAA9C;AACH;;AAHqB,SAAnB,CAAP;AAKH,OAXM,CAAP;AAYH;AA5CL;;AAAA;AAAA","sourcesContent":["const Rx = require('rxjs');\nconst { defaultIfEmpty, delay, filter, mapTo, skip, take, takeWhile } = require('rxjs/operators');\n\nconst defaults = require('../defaults');\n\nmodule.exports = class RestartProcess {\n    constructor({ delay, tries, logger, scheduler }) {\n        this.delay = +delay || defaults.restartDelay;\n        this.tries = +tries || defaults.restartTries;\n        this.logger = logger;\n        this.scheduler = scheduler;\n    }\n\n    handle(commands) {\n        if (this.tries === 0) {\n            return commands;\n        }\n\n        commands.map(command => command.close.pipe(\n            take(this.tries),\n            takeWhile(code => code !== 0)\n        )).map((failure, index) => Rx.merge(\n            // Delay the emission (so that the restarts happen on time),\n            // explicitly telling the subscriber that a restart is needed\n            failure.pipe(delay(this.delay, this.scheduler), mapTo(true)),\n            // Skip the first N emissions (as these would be duplicates of the above),\n            // meaning it will be empty because of success, or failed all N times,\n            // and no more restarts should be attempted.\n            failure.pipe(skip(this.tries), defaultIfEmpty(false))\n        ).subscribe(restart => {\n            const command = commands[index];\n            if (restart) {\n                this.logger.logCommandEvent(`${command.command} restarted`, command);\n                command.start();\n            }\n        }));\n\n        return commands.map(command => {\n            const closeStream = command.close.pipe(filter((value, emission) => {\n                // We let all success codes pass, and failures only after restarting won't happen again\n                return value === 0 || emission >= this.tries;\n            }));\n\n            return new Proxy(command, {\n                get(target, prop) {\n                    return prop === 'close' ? closeStream : target[prop];\n                }\n            });\n        });\n    }\n};\n"]},"metadata":{},"sourceType":"script"}