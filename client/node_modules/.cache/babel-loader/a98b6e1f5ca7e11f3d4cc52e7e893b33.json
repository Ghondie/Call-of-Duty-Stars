{"ast":null,"code":"var assert = require('assert');\n\nvar _ = require('lodash');\n\nvar spawn = require('spawn-command');\n\nvar treeKill = require('tree-kill');\n\nvar StripQuotes = require('./command-parser/strip-quotes');\n\nvar ExpandNpmShortcut = require('./command-parser/expand-npm-shortcut');\n\nvar ExpandNpmWildcard = require('./command-parser/expand-npm-wildcard');\n\nvar CompletionListener = require('./completion-listener');\n\nvar getSpawnOpts = require('./get-spawn-opts');\n\nvar Command = require('./command');\n\nvar defaults = {\n  spawn,\n  kill: treeKill,\n  raw: false,\n  controllers: []\n};\n\nmodule.exports = function (commands, options) {\n  assert.ok(Array.isArray(commands), '[concurrently] commands should be an array');\n  assert.notStrictEqual(commands.length, 0, '[concurrently] no commands provided');\n  options = _.defaults(options, defaults);\n  var commandParsers = [new StripQuotes(), new ExpandNpmShortcut(), new ExpandNpmWildcard()];\n  var spawnOpts = getSpawnOpts({\n    raw: options.raw\n  });\n  commands = _(commands).map(mapToCommandInfo).flatMap(function (command) {\n    return parseCommand(command, commandParsers);\n  }).map(function (command, index) {\n    return new Command(Object.assign({\n      index,\n      spawnOpts,\n      killProcess: options.kill,\n      spawn: options.spawn\n    }, command));\n  }).value();\n  commands = options.controllers.reduce(function (prevCommands, controller) {\n    return controller.handle(prevCommands);\n  }, commands);\n  commands.forEach(function (command) {\n    return command.start();\n  });\n  return new CompletionListener({\n    successCondition: options.successCondition\n  }).listen(commands);\n};\n\nfunction mapToCommandInfo(command) {\n  return {\n    command: command.command || command,\n    name: command.name || '',\n    prefixColor: command.prefixColor || ''\n  };\n}\n\nfunction parseCommand(command, parsers) {\n  return parsers.reduce(function (commands, parser) {\n    return _.flatMap(commands, function (command) {\n      return parser.parse(command);\n    });\n  }, _.castArray(command));\n}","map":{"version":3,"sources":["C:/Users/Alex/Desktop/project-3/repo/cod-tracker-auth/node_modules/concurrently/src/concurrently.js"],"names":["assert","require","_","spawn","treeKill","StripQuotes","ExpandNpmShortcut","ExpandNpmWildcard","CompletionListener","getSpawnOpts","Command","defaults","kill","raw","controllers","module","exports","commands","options","ok","Array","isArray","notStrictEqual","length","commandParsers","spawnOpts","map","mapToCommandInfo","flatMap","command","parseCommand","index","Object","assign","killProcess","value","reduce","prevCommands","controller","handle","forEach","start","successCondition","listen","name","prefixColor","parsers","parser","parse","castArray"],"mappings":"AAAA,IAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMC,CAAC,GAAGD,OAAO,CAAC,QAAD,CAAjB;;AACA,IAAME,KAAK,GAAGF,OAAO,CAAC,eAAD,CAArB;;AACA,IAAMG,QAAQ,GAAGH,OAAO,CAAC,WAAD,CAAxB;;AAEA,IAAMI,WAAW,GAAGJ,OAAO,CAAC,+BAAD,CAA3B;;AACA,IAAMK,iBAAiB,GAAGL,OAAO,CAAC,sCAAD,CAAjC;;AACA,IAAMM,iBAAiB,GAAGN,OAAO,CAAC,sCAAD,CAAjC;;AAEA,IAAMO,kBAAkB,GAAGP,OAAO,CAAC,uBAAD,CAAlC;;AAEA,IAAMQ,YAAY,GAAGR,OAAO,CAAC,kBAAD,CAA5B;;AACA,IAAMS,OAAO,GAAGT,OAAO,CAAC,WAAD,CAAvB;;AAEA,IAAMU,QAAQ,GAAG;AACbR,EAAAA,KADa;AAEbS,EAAAA,IAAI,EAAER,QAFO;AAGbS,EAAAA,GAAG,EAAE,KAHQ;AAIbC,EAAAA,WAAW,EAAE;AAJA,CAAjB;;AAOAC,MAAM,CAACC,OAAP,GAAiB,UAACC,QAAD,EAAWC,OAAX,EAAuB;AACpClB,EAAAA,MAAM,CAACmB,EAAP,CAAUC,KAAK,CAACC,OAAN,CAAcJ,QAAd,CAAV,EAAmC,4CAAnC;AACAjB,EAAAA,MAAM,CAACsB,cAAP,CAAsBL,QAAQ,CAACM,MAA/B,EAAuC,CAAvC,EAA0C,qCAA1C;AAEAL,EAAAA,OAAO,GAAGhB,CAAC,CAACS,QAAF,CAAWO,OAAX,EAAoBP,QAApB,CAAV;AAEA,MAAMa,cAAc,GAAG,CACnB,IAAInB,WAAJ,EADmB,EAEnB,IAAIC,iBAAJ,EAFmB,EAGnB,IAAIC,iBAAJ,EAHmB,CAAvB;AAMA,MAAMkB,SAAS,GAAGhB,YAAY,CAAC;AAAEI,IAAAA,GAAG,EAAEK,OAAO,CAACL;AAAf,GAAD,CAA9B;AAEAI,EAAAA,QAAQ,GAAGf,CAAC,CAACe,QAAD,CAAD,CACNS,GADM,CACFC,gBADE,EAENC,OAFM,CAEE,UAAAC,OAAO;AAAA,WAAIC,YAAY,CAACD,OAAD,EAAUL,cAAV,CAAhB;AAAA,GAFT,EAGNE,GAHM,CAGF,UAACG,OAAD,EAAUE,KAAV;AAAA,WAAoB,IAAIrB,OAAJ,CAAYsB,MAAM,CAACC,MAAP,CAAc;AAC/CF,MAAAA,KAD+C;AAE/CN,MAAAA,SAF+C;AAG/CS,MAAAA,WAAW,EAAEhB,OAAO,CAACN,IAH0B;AAI/CT,MAAAA,KAAK,EAAEe,OAAO,CAACf;AAJgC,KAAd,EAKlC0B,OALkC,CAAZ,CAApB;AAAA,GAHE,EASNM,KATM,EAAX;AAWAlB,EAAAA,QAAQ,GAAGC,OAAO,CAACJ,WAAR,CAAoBsB,MAApB,CACP,UAACC,YAAD,EAAeC,UAAf;AAAA,WAA8BA,UAAU,CAACC,MAAX,CAAkBF,YAAlB,CAA9B;AAAA,GADO,EAEPpB,QAFO,CAAX;AAKAA,EAAAA,QAAQ,CAACuB,OAAT,CAAiB,UAAAX,OAAO;AAAA,WAAIA,OAAO,CAACY,KAAR,EAAJ;AAAA,GAAxB;AACA,SAAO,IAAIjC,kBAAJ,CAAuB;AAAEkC,IAAAA,gBAAgB,EAAExB,OAAO,CAACwB;AAA5B,GAAvB,EAAuEC,MAAvE,CAA8E1B,QAA9E,CAAP;AACH,CAhCD;;AAkCA,SAASU,gBAAT,CAA0BE,OAA1B,EAAmC;AAC/B,SAAO;AACHA,IAAAA,OAAO,EAAEA,OAAO,CAACA,OAAR,IAAmBA,OADzB;AAEHe,IAAAA,IAAI,EAAEf,OAAO,CAACe,IAAR,IAAgB,EAFnB;AAGHC,IAAAA,WAAW,EAAEhB,OAAO,CAACgB,WAAR,IAAuB;AAHjC,GAAP;AAKH;;AAED,SAASf,YAAT,CAAsBD,OAAtB,EAA+BiB,OAA/B,EAAwC;AACpC,SAAOA,OAAO,CAACV,MAAR,CACH,UAACnB,QAAD,EAAW8B,MAAX;AAAA,WAAsB7C,CAAC,CAAC0B,OAAF,CAAUX,QAAV,EAAoB,UAAAY,OAAO;AAAA,aAAIkB,MAAM,CAACC,KAAP,CAAanB,OAAb,CAAJ;AAAA,KAA3B,CAAtB;AAAA,GADG,EAEH3B,CAAC,CAAC+C,SAAF,CAAYpB,OAAZ,CAFG,CAAP;AAIH","sourcesContent":["const assert = require('assert');\nconst _ = require('lodash');\nconst spawn = require('spawn-command');\nconst treeKill = require('tree-kill');\n\nconst StripQuotes = require('./command-parser/strip-quotes');\nconst ExpandNpmShortcut = require('./command-parser/expand-npm-shortcut');\nconst ExpandNpmWildcard = require('./command-parser/expand-npm-wildcard');\n\nconst CompletionListener = require('./completion-listener');\n\nconst getSpawnOpts = require('./get-spawn-opts');\nconst Command = require('./command');\n\nconst defaults = {\n    spawn,\n    kill: treeKill,\n    raw: false,\n    controllers: []\n};\n\nmodule.exports = (commands, options) => {\n    assert.ok(Array.isArray(commands), '[concurrently] commands should be an array');\n    assert.notStrictEqual(commands.length, 0, '[concurrently] no commands provided');\n\n    options = _.defaults(options, defaults);\n\n    const commandParsers = [\n        new StripQuotes(),\n        new ExpandNpmShortcut(),\n        new ExpandNpmWildcard()\n    ];\n\n    const spawnOpts = getSpawnOpts({ raw: options.raw });\n\n    commands = _(commands)\n        .map(mapToCommandInfo)\n        .flatMap(command => parseCommand(command, commandParsers))\n        .map((command, index) => new Command(Object.assign({\n            index,\n            spawnOpts,\n            killProcess: options.kill,\n            spawn: options.spawn,\n        }, command)))\n        .value();\n\n    commands = options.controllers.reduce(\n        (prevCommands, controller) => controller.handle(prevCommands),\n        commands\n    );\n\n    commands.forEach(command => command.start());\n    return new CompletionListener({ successCondition: options.successCondition }).listen(commands);\n};\n\nfunction mapToCommandInfo(command) {\n    return {\n        command: command.command || command,\n        name: command.name || '',\n        prefixColor: command.prefixColor || '',\n    };\n}\n\nfunction parseCommand(command, parsers) {\n    return parsers.reduce(\n        (commands, parser) => _.flatMap(commands, command => parser.parse(command)),\n        _.castArray(command)\n    );\n}\n"]},"metadata":{},"sourceType":"script"}